// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Built with zod-codegen@1.0.1
// Latest edit: Thu, 13 Nov 2025 13:32:35 GMT
// Source file: ./samples/pokeapi-openapi.json
/* eslint-disable */
// @ts-nocheck

// Imports
import {z} from 'zod';

// Components schemas
export const NamedAPIResource = z.object({
  name: z.string(),
  url: z.string().url(),
});
export const PokemonType = z.object({
  slot: z.number().int().optional(),
  type: NamedAPIResource.optional(),
});
export const PokemonAbility = z.object({
  ability: NamedAPIResource.optional(),
  is_hidden: z.boolean().optional(),
  slot: z.number().int().optional(),
});
export const PokemonSprites = z.object({
  front_default: z.string().url().optional(),
  front_shiny: z.string().url().optional(),
  back_default: z.string().url().optional(),
  back_shiny: z.string().url().optional(),
});
export const Pokemon = z.object({
  id: z.number().int(),
  name: z.string(),
  height: z.number().int().optional(),
  weight: z.number().int().optional(),
  base_experience: z.number().int().optional(),
  types: z.array(PokemonType).optional(),
  abilities: z.array(PokemonAbility).optional(),
  sprites: PokemonSprites.optional(),
});
export const PokemonListResponse = z.object({
  count: z.number().int(),
  next: z.string().url().optional(),
  previous: z.string().url().optional(),
  results: z.array(NamedAPIResource),
});
export const defaultBaseUrl = 'https://pokeapi.co/api/v2';

// Client class
export class PokAPI {
  readonly #baseUrl: string;
  constructor(baseUrl: string = defaultBaseUrl, _?: unknown) {
    this.#baseUrl = baseUrl;
  }
  protected getBaseRequestOptions(): Partial<Omit<RequestInit, 'method' | 'body'>> {
    return {};
  }
  async #makeRequest<T>(
    method: string,
    path: string,
    options: _params___Record_string__string___number___boolean___data___unknown__contentType___string__headers___Record_string__string__ = {},
  ): Promise<T> {
    const baseUrl = `${this.#baseUrl}${path}`;
    const url =
      options.params && Object.keys(options.params).length > 0
        ? (() => {
            Object.entries(options.params).forEach(([key, value]) => {
              new URL(baseUrl).searchParams.set(key, String(value));
            });
            return new URL(baseUrl).toString();
          })()
        : new URL(baseUrl).toString();
    const baseOptions = this.getBaseRequestOptions();
    const contentType =
      options.contentType === 'application/x-www-form-urlencoded'
        ? 'application/x-www-form-urlencoded'
        : 'application/json';
    const baseHeaders = baseOptions.headers !== undefined ? baseOptions.headers : {};
    const headers = Object.assign(
      {},
      baseHeaders,
      {'Content-Type': contentType},
      options.headers !== undefined ? options.headers : {},
    );
    const body =
      options.data !== undefined
        ? options.contentType === 'application/x-www-form-urlencoded'
          ? (() => {
              const params = new URLSearchParams();
              Object.entries(options.data).forEach(([key, value]) => {
                params.set(key, String(value));
              });
              return params.toString();
            })()
          : JSON.stringify(options.data)
        : null;
    const response = await fetch(url, Object.assign({}, baseOptions, {method, headers: headers, body: body}));
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    return await response.json();
  }
  async getPokemonById(id: string): Promise<Pokemon> {
    return Pokemon.parse(await this.#makeRequest('GET', `/pokemon/${id}`, {}));
  }
  async getPokemonList(limit?: number, offset?: number): Promise<PokemonListResponse> {
    return PokemonListResponse.parse(
      await this.#makeRequest('GET', '/pokemon', {params: {limit: limit, offset: offset}}),
    );
  }
}
