// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Built with zod-codegen@1.0.1
// Latest edit: Thu, 13 Nov 2025 13:36:35 GMT
// Source file: ./samples/swagger-petstore.yaml
/* eslint-disable */
// @ts-nocheck

// Imports
import {z} from 'zod';

// Components schemas
export const Order = z.object({
  id: z.number().int().optional(),
  petId: z.number().int().optional(),
  quantity: z.number().int().optional(),
  shipDate: z.string().datetime().optional(),
  status: z.enum(['placed', 'approved', 'delivered']).optional(),
  complete: z.boolean().optional(),
});
export const Address = z.object({
  street: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zip: z.string().optional(),
});
export const Customer = z.object({
  id: z.number().int().optional(),
  username: z.string().optional(),
  address: z.array(Address).optional(),
});
export const Category = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
});
export const User = z.object({
  id: z.number().int().optional(),
  username: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  email: z.string().optional(),
  password: z.string().optional(),
  phone: z.string().optional(),
  userStatus: z.number().int().optional(),
});
export const Tag = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
});
export const Pet = z.object({
  id: z.number().int().optional(),
  name: z.string(),
  category: Category.optional(),
  photoUrls: z.array(z.string()),
  tags: z.array(Tag).optional(),
  status: z.enum(['available', 'pending', 'sold']).optional(),
});
export const ApiResponse = z.object({
  code: z.number().int().optional(),
  type: z.string().optional(),
  message: z.string().optional(),
});
export const serverConfigurations = [
  {
    url: 'https://petstore3.swagger.io/api/v3',
  },
];
export const defaultBaseUrl = 'https://petstore3.swagger.io/api/v3';
export type ClientOptions = {
  baseUrl?: string;
  serverIndex?: number;
  serverVariables?: Record<string, string>;
};
function resolveServerUrl(serverIndex?: number | undefined, serverVariables?: Record<string, string> = {}): string {
  const configs = [
    {
      url: 'https://petstore3.swagger.io/api/v3',
    },
  ];
  const idx = serverIndex ?? 0;
  if (idx < configs.length) {
    const config = configs[idx];
    let url = config.url;
    if (config.variables && serverVariables) {
      for (const [key, value] of Object.entries(serverVariables)) {
        url = url.replace(new RegExp('\\{' + key + '\\}', 'g'), value);
      }
    }
    return url;
  }
  return 'https://petstore3.swagger.io/api/v3';
}

// Client class
export class SwaggerPetstoreOpenAPI30 {
  readonly #baseUrl: string;
  constructor(options: ClientOptions) {
    const resolvedUrl =
      options.baseUrl !== null ? options.baseUrl : resolveServerUrl(options.serverIndex, options.serverVariables);
    this.#baseUrl = resolvedUrl;
  }
  protected getBaseRequestOptions(): Partial<Omit<RequestInit, 'method' | 'body'>> {
    return {};
  }
  async #makeRequest<T>(
    method: string,
    path: string,
    options: _params___Record_string__string___number___boolean___data___unknown__contentType___string__headers___Record_string__string__ = {},
  ): Promise<T> {
    const baseUrl = `${this.#baseUrl}${path}`;
    const url =
      options.params && Object.keys(options.params).length > 0
        ? (() => {
            Object.entries(options.params).forEach(([key, value]) => {
              new URL(baseUrl).searchParams.set(key, String(value));
            });
            return new URL(baseUrl).toString();
          })()
        : new URL(baseUrl).toString();
    const baseOptions = this.getBaseRequestOptions();
    const contentType =
      options.contentType === 'application/x-www-form-urlencoded'
        ? 'application/x-www-form-urlencoded'
        : 'application/json';
    const baseHeaders = baseOptions.headers !== undefined ? baseOptions.headers : {};
    const headers = Object.assign(
      {},
      baseHeaders,
      {'Content-Type': contentType},
      options.headers !== undefined ? options.headers : {},
    );
    const body =
      options.data !== undefined
        ? options.contentType === 'application/x-www-form-urlencoded'
          ? (() => {
              const params = new URLSearchParams();
              Object.entries(options.data).forEach(([key, value]) => {
                params.set(key, String(value));
              });
              return params.toString();
            })()
          : JSON.stringify(options.data)
        : null;
    const response = await fetch(url, Object.assign({}, baseOptions, {method, headers: headers, body: body}));
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    return await response.json();
  }
  async addPet(body: Pet): Promise<Pet> {
    return Pet.parse(
      await this.#makeRequest('POST', '/pet', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  async updatePet(body: Pet): Promise<Pet> {
    return Pet.parse(
      await this.#makeRequest('PUT', '/pet', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  async findPetsByStatus(status?: string): Promise<Pet[]> {
    return await this.#makeRequest('GET', '/pet/findByStatus', {params: {status: status}});
  }
  async findPetsByTags(tags?: string[]): Promise<Pet[]> {
    return await this.#makeRequest('GET', '/pet/findByTags', {params: {tags: tags}});
  }
  async getPetById(petId: number): Promise<Pet> {
    return Pet.parse(await this.#makeRequest('GET', `/pet/${petId}`, {}));
  }
  async updatePetWithForm(petId: number, name?: string, status?: string): Promise<void> {
    return await this.#makeRequest('POST', `/pet/${petId}`, {params: {name: name, status: status}});
  }
  async deletePet(petId: number): Promise<void> {
    return await this.#makeRequest('DELETE', `/pet/${petId}`, {});
  }
  async uploadFile(petId: number, additionalMetadata?: string): Promise<ApiResponse> {
    return ApiResponse.parse(
      await this.#makeRequest('POST', `/pet/${petId}/uploadImage`, {params: {additionalMetadata: additionalMetadata}}),
    );
  }
  async getInventory(): Promise<Record<string, unknown>> {
    return await this.#makeRequest('GET', '/store/inventory', {});
  }
  async placeOrder(body?: Order): Promise<Order> {
    return Order.parse(
      await this.#makeRequest('POST', '/store/order', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  async getOrderById(orderId: number): Promise<Order> {
    return Order.parse(await this.#makeRequest('GET', `/store/order/${orderId}`, {}));
  }
  async deleteOrder(orderId: number): Promise<void> {
    return await this.#makeRequest('DELETE', `/store/order/${orderId}`, {});
  }
  async createUser(body?: User): Promise<User> {
    return User.parse(
      await this.#makeRequest('POST', '/user', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  async createUsersWithListInput(body?: User[]): Promise<User> {
    return User.parse(await this.#makeRequest('POST', '/user/createWithList', {data: body}));
  }
  async loginUser(username?: string, password?: string): Promise<string> {
    return await this.#makeRequest('GET', '/user/login', {params: {username: username, password: password}});
  }
  async logoutUser(): Promise<void> {
    return await this.#makeRequest('GET', '/user/logout', {});
  }
  async getUserByName(username: string): Promise<User> {
    return User.parse(await this.#makeRequest('GET', `/user/${username}`, {}));
  }
  async updateUser(username: string, body?: User): Promise<void> {
    return await this.#makeRequest('PUT', `/user/${username}`, {
      data: body,
      contentType: 'application/x-www-form-urlencoded',
    });
  }
  async deleteUser(username: string): Promise<void> {
    return await this.#makeRequest('DELETE', `/user/${username}`, {});
  }
}
