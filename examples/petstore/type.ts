// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Built with zod-codegen@1.2.0
// Latest edit: Wed, 19 Nov 2025 16:38:29 GMT
// Source file: ./samples/swagger-petstore.yaml
/* eslint-disable */
// @ts-nocheck

// Imports
import {z} from 'zod';

// Components schemas
export const Order = z.object({
  id: z.number().int().optional(),
  petId: z.number().int().optional(),
  quantity: z.number().int().optional(),
  shipDate: z.string().datetime().optional(),
  status: z.enum(['placed', 'approved', 'delivered']).optional(),
  complete: z.boolean().optional(),
});
export const Address = z.object({
  street: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zip: z.string().optional(),
});
export const Customer = z.object({
  id: z.number().int().optional(),
  username: z.string().optional(),
  address: z.array(Address).optional(),
});
export const Category = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
});
export const User = z.object({
  id: z.number().int().optional(),
  username: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  email: z.string().optional(),
  password: z.string().optional(),
  phone: z.string().optional(),
  userStatus: z.number().int().optional(),
});
export const Tag = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
});
export const Pet = z.object({
  id: z.number().int().optional(),
  name: z.string(),
  category: Category.optional(),
  photoUrls: z.array(z.string()),
  tags: z.array(Tag).optional(),
  status: z.enum(['available', 'pending', 'sold']).optional(),
});
export const ApiResponse = z.object({
  code: z.number().int().optional(),
  type: z.string().optional(),
  message: z.string().optional(),
});
export type Order = z.infer<typeof Order>;
export type Address = z.infer<typeof Address>;
export type Customer = z.infer<typeof Customer>;
export type Category = z.infer<typeof Category>;
export type User = z.infer<typeof User>;
export type Tag = z.infer<typeof Tag>;
export type Pet = z.infer<typeof Pet>;
export type ApiResponse = z.infer<typeof ApiResponse>;
export const serverConfigurations = [
  {
    url: 'https://petstore3.swagger.io/api/v3',
  },
];
export const defaultBaseUrl = 'https://petstore3.swagger.io/api/v3';
export type ClientOptions = {
  baseUrl?: string;
  serverIndex?: number;
  serverVariables?: Record<string, string>;
};
function resolveServerUrl(serverIndex?: number | undefined, serverVariables?: Record<string, string> = {}): string {
  const configs = [
    {
      url: 'https://petstore3.swagger.io/api/v3',
    },
  ];
  const idx = serverIndex ?? 0;
  if (idx < configs.length) {
    const config = configs[idx];
    let url = config.url;
    if (config.variables && serverVariables) {
      for (const [key, value] of Object.entries(serverVariables)) {
        url = url.replace(new RegExp('\\{' + key + '\\}', 'g'), value);
      }
    }
    return url;
  }
  return 'https://petstore3.swagger.io/api/v3';
}

// Client class
export class SwaggerPetstoreOpenAPI30 {
  readonly #baseUrl: string;
  constructor(options: ClientOptions) {
    const resolvedUrl =
      options.baseUrl !== null ? options.baseUrl : resolveServerUrl(options.serverIndex, options.serverVariables);
    this.#baseUrl = resolvedUrl;
  }
  protected getBaseRequestOptions(): Partial<Omit<RequestInit, 'method' | 'body'>> {
    return {};
  }
  async #makeRequest<T>(
    method: string,
    path: string,
    options: _params___Record_string__string___number___boolean___data___unknown__contentType___string__headers___Record_string__string__ = {},
  ): Promise<T> {
    const baseUrl = `${this.#baseUrl}${path}`;
    const url =
      options.params && Object.keys(options.params).length > 0
        ? (() => {
            Object.entries(options.params).forEach(([key, value]) => {
              new URL(baseUrl).searchParams.set(key, String(value));
            });
            return new URL(baseUrl).toString();
          })()
        : new URL(baseUrl).toString();
    const baseOptions = this.getBaseRequestOptions();
    const contentType =
      options.contentType === 'application/x-www-form-urlencoded'
        ? 'application/x-www-form-urlencoded'
        : 'application/json';
    const baseHeaders = baseOptions.headers !== undefined ? baseOptions.headers : {};
    const headers = Object.assign(
      {},
      baseHeaders,
      {'Content-Type': contentType},
      options.headers !== undefined ? options.headers : {},
    );
    const body =
      options.data !== undefined
        ? options.contentType === 'application/x-www-form-urlencoded'
          ? (() => {
              const params = new URLSearchParams();
              Object.entries(options.data).forEach(([key, value]) => {
                params.set(key, String(value));
              });
              return params.toString();
            })()
          : JSON.stringify(options.data)
        : null;
    const response = await fetch(url, Object.assign({}, baseOptions, {method, headers: headers, body: body}));
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    return await response.json();
  }
  /**
   * Add a new pet to the store
   * @param body Create a new pet in the store
   * @returns {Pet}
   */
  async addPet(body: Pet): Promise<Pet> {
    return Pet.parse(
      await this.#makeRequest('POST', '/pet', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  /**
   * Update an existing pet
   *
   * Update an existing pet by Id
   * @param body Update an existent pet in the store
   * @returns {Pet}
   */
  async updatePet(body: Pet): Promise<Pet> {
    return Pet.parse(
      await this.#makeRequest('PUT', '/pet', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  /**
   * Finds Pets by status
   *
   * Multiple status values can be provided with comma separated strings
   *
   * @param status Status values that need to be considered for filter
   * @returns {Pet[]}
   */
  async findPetsByStatus(status?: string): Promise<Pet[]> {
    return await this.#makeRequest('GET', '/pet/findByStatus', {params: {status: status}});
  }
  /**
   * Finds Pets by tags
   *
   * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
   *
   * @param tags Tags to filter by
   * @returns {Pet[]}
   */
  async findPetsByTags(tags?: string[]): Promise<Pet[]> {
    return await this.#makeRequest('GET', '/pet/findByTags', {params: {tags: tags}});
  }
  /**
   * Find pet by ID
   *
   * Returns a single pet
   *
   * @param petId ID of pet to return
   * @returns {Pet}
   */
  async getPetById(petId: number): Promise<Pet> {
    return Pet.parse(await this.#makeRequest('GET', `/pet/${petId}`, {}));
  }
  /**
   * Updates a pet in the store with form data
   *
   * @param petId ID of pet that needs to be updated
   * @param name Name of pet that needs to be updated
   * @param status Status of pet that needs to be updated
   * @returns {void}
   */
  async updatePetWithForm(petId: number, name?: string, status?: string): Promise<void> {
    return await this.#makeRequest('POST', `/pet/${petId}`, {params: {name: name, status: status}});
  }
  /**
   * Deletes a pet
   *
   * delete a pet
   *
   * @param api_key
   * @param petId Pet id to delete
   * @returns {void}
   */
  async deletePet(petId: number): Promise<void> {
    return await this.#makeRequest('DELETE', `/pet/${petId}`, {});
  }
  /**
   * uploads an image
   *
   * @param petId ID of pet to update
   * @param additionalMetadata Additional Metadata
   * @param body
   * @returns {ApiResponse}
   */
  async uploadFile(petId: number, additionalMetadata?: string): Promise<ApiResponse> {
    return ApiResponse.parse(
      await this.#makeRequest('POST', `/pet/${petId}/uploadImage`, {params: {additionalMetadata: additionalMetadata}}),
    );
  }
  /**
   * Returns pet inventories by status
   *
   * Returns a map of status codes to quantities
   * @returns {Record<string, unknown>}
   */
  async getInventory(): Promise<Record<string, unknown>> {
    return await this.#makeRequest('GET', '/store/inventory', {});
  }
  /**
   * Place an order for a pet
   *
   * Place a new order in the store
   * @param body
   * @returns {Order}
   */
  async placeOrder(body?: Order): Promise<Order> {
    return Order.parse(
      await this.#makeRequest('POST', '/store/order', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  /**
   * Find purchase order by ID
   *
   * For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
   *
   * @param orderId ID of order that needs to be fetched
   * @returns {Order}
   */
  async getOrderById(orderId: number): Promise<Order> {
    return Order.parse(await this.#makeRequest('GET', `/store/order/${orderId}`, {}));
  }
  /**
   * Delete purchase order by ID
   *
   * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
   *
   * @param orderId ID of the order that needs to be deleted
   * @returns {void}
   */
  async deleteOrder(orderId: number): Promise<void> {
    return await this.#makeRequest('DELETE', `/store/order/${orderId}`, {});
  }
  /**
   * Create user
   *
   * This can only be done by the logged in user.
   * @param body Created user object
   * @returns {User}
   */
  async createUser(body?: User): Promise<User> {
    return User.parse(
      await this.#makeRequest('POST', '/user', {data: body, contentType: 'application/x-www-form-urlencoded'}),
    );
  }
  /**
   * Creates list of users with given input array
   * @param body
   * @returns {User}
   */
  async createUsersWithListInput(body?: User[]): Promise<User> {
    return User.parse(await this.#makeRequest('POST', '/user/createWithList', {data: body}));
  }
  /**
   * Logs user into the system
   *
   * @param username The user name for login
   * @param password The password for login in clear text
   * @returns {string}
   */
  async loginUser(username?: string, password?: string): Promise<string> {
    return await this.#makeRequest('GET', '/user/login', {params: {username: username, password: password}});
  }
  /**
   * Logs out current logged in user session
   * @returns {void}
   */
  async logoutUser(): Promise<void> {
    return await this.#makeRequest('GET', '/user/logout', {});
  }
  /**
   * Get user by user name
   *
   * @param username The name that needs to be fetched. Use user1 for testing.
   * @returns {User}
   */
  async getUserByName(username: string): Promise<User> {
    return User.parse(await this.#makeRequest('GET', `/user/${username}`, {}));
  }
  /**
   * Update user
   *
   * This can only be done by the logged in user.
   *
   * @param username name that need to be deleted
   * @param body Update an existent user in the store
   * @returns {void}
   */
  async updateUser(username: string, body?: User): Promise<void> {
    return await this.#makeRequest('PUT', `/user/${username}`, {
      data: body,
      contentType: 'application/x-www-form-urlencoded',
    });
  }
  /**
   * Delete user
   *
   * This can only be done by the logged in user.
   *
   * @param username The name that needs to be deleted
   * @returns {void}
   */
  async deleteUser(username: string): Promise<void> {
    return await this.#makeRequest('DELETE', `/user/${username}`, {});
  }
}
